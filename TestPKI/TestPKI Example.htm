<!DOCTYPE html>
<!-- saved from url=(0048)https://guanhangt.github.io/TestPKIoverFIDO.html -->
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>TestPKI Example</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Ensure use of most common Unicode characters -->

    <link rel="stylesheet" href="./TestPKI Example_files/spectre.min.css">
    <!-- Considered an "experimental" feature -->
    <link rel="stylesheet" href="./TestPKI Example_files/spectre-exp.min.css">
    <!-- Spectre.css icons are used -->
    <link rel="stylesheet" href="./TestPKI Example_files/spectre-icons.min.css">

    <script src="./TestPKI Example_files/webfont.js" async=""></script>
    <script src="./TestPKI Example_files/cbor.js"></script>
    <script src="./TestPKI Example_files/helpers.js"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());
        gtag('config', 'UA-3776848-14');
    </script>
    <script>
        (function(d) {
            var wf = d.createElement('script'),
                s = d.scripts[0];
            wf.src = 'https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js';
            wf.async = true;
            s.parentNode.insertBefore(wf, s);
        })(document);
    </script>
    <script src="./TestPKI Example_files/jquery.min.js"></script>
    <script src="./TestPKI Example_files/bootstrap.min.js" integrity="sha256-Tz+u7EaSlLYQ9sqCqhzCszaP1WYRsxxVHC7iJP6ttBE=" crossorigin="anonymous"></script>
    <script async="" src="./TestPKI Example_files/bundle.js"></script>
    <script>
        function displayCert(strCertificate) {

            $('#certificate').text(strCertificate)
            window.setTimeout(function() {
                console.log("Timeout ... trigger decode");
                $("#decode .btn").click();
            }, 100);


        }

        $(document).ready(function() {

            var btnDecode = document.getElementById('decode');
            btnDecode.style.visibility = 'hidden';

            var ctrlErr = document.getElementById('upload-error');
            ctrlErr.style.visibility = 'hidden';

            var ctrlCert = document.getElementById('certificate');
            ctrlCert.style.visibility = 'hidden';
        });
    </script>
</head>

<body>
    <table style="height: 492px; width: 888px;">
        <tbody>
            <tr>
                <td style="width: 496px;"><img src="./TestPKI Example_files/idem_key_on_pc.png" alt="Idem Key " width="477" height="519">&nbsp;&nbsp;</td>
                <td style="width: 329px;">
                    <h1 style="text-align: center;"></h1>
                    <h3 style="text-align: center;">A demo of operating PKI over FIDO2 on PC</h3>
                    <table style="height: 160px;" border="1" width="395">
                        <tbody>
                            <tr>
                                <td style="width: 385px;">
                                    <p style="text-align: center;">Operate Certificate by CKA_LABEL</p>

                                    <p>
                                    </p>
                                    <form style="text-align: center;" id="use-label" onsubmit="return false">
                                        <input type="text" name="ckaLabel" placeholder="CKA_LABEL" style="width: 342px; height:41px">

                                    </form>
                                    <p></p>
                                    <form style="text-align: center;" id="search-ckalabel" onsubmit="return false">
                                        <button class="btn btn-primary" action="submit" style="width: 162px; height:34px;background-color: #008CBA;">Read
                                            Certificate</button>
                                    </form>
                                    <p>
                                    </p>
                                    <form style="text-align: center;" id="sign-byckalabel" onsubmit="return false">
                                        <button class="btn btn-primary" action="submit" style="width: 162px; height:34px;background-color: #008CBA;">Test
                                                Sign</button>
                                    </form>
                                    <p></p>
                                </td>
                            </tr>
                            <tr>
                                <td style="width: 385px;">
                                    <p style="text-align: center;">Operate Certificate by Index (1~8)</p>
                                    <p>
                                    </p>
                                    <form style="text-align:center" id="use-index" onsubmit="return false">
                                        <input type="number" name="certIndex" placeholder="index" style="width: 342px; height:41px">
                                    </form>
                                    <p></p>
                                    <form style="text-align: center;" id="find-index" onsubmit="return false">
                                        <button class="btn btn-primary" action="submit" style="width: 162px; height:34px;background-color: #008CBA;">Read
                                            Certificate</button>
                                    </form>
                                    <p>
                                    </p>
                                    <form style="text-align: center;" id="sign-byindex" onsubmit="return false">
                                        <button class="btn btn-primary" action="submit" style="width: 162px; height:34px;background-color: #008CBA;">Test
                                                Sign</button>
                                    </form>
                                    <p></p>
                                </td>
                            </tr>


                        </tbody>
                    </table>

                    <h3 style="text-align: center;">A demo of operating PKI over FIDO2 on ï¼¡ndroid</h3>
                    <table style="height: 160px;" border="1" width="395">
                        <tbody>

                            <tr>
                                <td style="width: 385px;">
                                    <p style="text-align: center;">Operate Certificate by CKA_LABEL</p>

                                    <p>
                                    </p>
                                    <form style="text-align: center;" id="android-ckalabel-pin" onsubmit="return false">
                                        <input type="text" name="pin" placeholder="User PIN" style="width: 342px; height:41px">
                                    </form>
                                    <p></p>

                                    <p>
                                    </p>
                                    <form style="text-align: center;" id="android-label" onsubmit="return false">
                                        <input type="text" name="ckaLabel" placeholder="CKA_LABEL" style="width: 342px; height:41px">
                                    </form>
                                    <p></p>

                                    <p>
                                    </p>
                                    <form style="text-align: center;" id="android-ckalabel-getassertion" onsubmit="return false">
                                        <button class="btn btn-primary" action="submit" style="width: 162px; height:34px;background-color: #008CBA;">Test
                                                Sign</button>
                                    </form>
                                    <p></p>
                                </td>
                            </tr>

                            <tr>
                                <td style="width: 385px;">
                                    <p style="text-align: center;">Operate Certificate by Index (1~8)</p>

                                    <p>
                                    </p>
                                    <form style="text-align: center;" id="android-index-pin" onsubmit="return false">
                                        <input type="text" name="pin" placeholder="User PIN" style="width: 342px; height:41px">
                                    </form>
                                    <p></p>

                                    <p>
                                    </p>
                                    <form style="text-align: center;" id="android-index" onsubmit="return false">
                                        <input type="number" name="certIndex" placeholder="index" style="width: 342px; height:41px">
                                    </form>
                                    <p></p>

                                    <p>
                                    </p>
                                    <form style="text-align: center;" id="android-index-getassertion" onsubmit="return false">
                                        <button class="btn btn-primary" action="submit" style="width: 162px; height:34px;background-color: #008CBA;">Test
                                                Sign</button>
                                    </form>
                                    <p></p>
                                </td>
                            </tr>


                        </tbody>
                    </table>
                </td>

                <td style="width: 329px;">
                    <h1 style="text-align: center;"></h1>
                    <h3 style="text-align: center;">A demo of operating PKI over FIDO2 on iOS/Mac with Safari</h3>
                    <table style="height: 160px;" border="1" width="395">
                        <tbody>
                            <tr>
                                <td style="width: 385px;">
                                    <p style="text-align: center;">Operate Certificate by CKA_LABEL</p>

                                    <p>
                                    </p>
                                    <form style="text-align: center;" id="use-label-safari" onsubmit="return false">
                                        <input type="text" name="ckaLabel" placeholder="CKA_LABEL" style="width: 342px; height:41px">

                                    </form>
                                    <p></p>

                                    <p>
                                    </p>
                                    <form style="text-align: center;" id="safari-pin-label" onsubmit="return false">
                                        <input type="text" name="pin" placeholder="User PIN" style="width: 342px; height:41px">
                                    </form>
                                    <p></p>

                                    <form style="text-align: center;" id="search-ckalabel-safari" onsubmit="return false">
                                        <button class="btn btn-primary" action="submit" style="width: 162px; height:34px;background-color: #008CBA;">Read
                                            Certificate</button>
                                    </form>
                                    <p>
                                    </p>
                                    <form style="text-align: center;" id="sign-ckalabel-safari" onsubmit="return false">
                                        <button class="btn btn-primary" action="submit" style="width: 162px; height:34px;background-color: #008CBA;">Test
                                                Sign</button>
                                    </form>
                                    <p></p>
                                </td>

                            </tr>
                            <tr>
                                <td style="width: 385px;">
                                    <p style="text-align: center;">Operate Certificate by Index (1~8)</p>
                                    <p>
                                    </p>
                                    <form style="text-align:center" id="use-index-safari" onsubmit="return false">
                                        <input type="number" name="certIndex" placeholder="index" style="width: 342px; height:41px">
                                    </form>
                                    <p></p>

                                    <p>
                                    </p>
                                    <form style="text-align: center;" id="safari-pin-index" onsubmit="return false">
                                        <input type="text" name="pin" placeholder="User PIN" style="width: 342px; height:41px">
                                    </form>
                                    <p></p>
                                    <p>
                                    </p>
                                    <form style="text-align: center;" id="find-index-safari" onsubmit="return false">
                                        <button class="btn btn-primary" action="submit" style="width: 162px; height:34px;background-color: #008CBA;">Read
                                                Certificate</button>
                                    </form>
                                    <p></p>

                                    <p>
                                    </p>
                                    <form style="text-align: center;" id="sign-index-safari" onsubmit="return false">
                                        <button class="btn btn-primary" action="submit" style="width: 162px; height:34px;background-color: #008CBA;">Test
                                                Sign</button>
                                    </form>
                                    <p></p>
                                </td>
                            </tr>


                        </tbody>
                    </table>
                </td>



            </tr>
        </tbody>
    </table>

    <div>
        <textarea style="width:100%;height:150px;" id="show-sign">
	</textarea>
    </div>

    <!--  Laurence -->
    <div class="container mt-2">
        <div id="form" class="mt-2 mb-2">
            <div class="container">
                <div class="row">
                    <div class="col">
                        <div class="card">
                            <div class="card-body">
                                <div id="results" class="mt-2">
                                    <div id="accordion">
                                        <div class="card">
                                            <div class="card-header" id="heading0"><span><button class="btn btn-link" data-toggle="collapse" data-target="#collapse0" aria-expanded="true" aria-controls="collapse0">20200528--00001</button></span></div>
                                            <div id="collapse0" class="collapse show" aria-labelledby="heading0" data-parent="#accordion">
                                                <div class="card-body">
                                                    <ul class="nav nav-tabs" role="tablist"></ul>
                                                    <div class="tab-content pt-3" style="height: 423px;">
                                                        <div class="tab-pane fade show active" id="basic0" role="tabpanel" aria-labelledby="basic-tab0">
                                                            <ul style="height: 410px;overflow-y: auto;">
                                                                <li><span>Issued  To: </span><span>C=TW, O=ChungHwa Telecom Co., Ltd., OU=FXML, CN=20200528--00001</span></li>
                                                                <li><span>Issued By: </span><span>C=TW, O=Chunghwa Telecom Co., Ltd., OU=Financial UCA for Testing - G4, CN=Test UCA of Financial PKI - G4</span></li>
                                                                <li><span>Serial Number: </span><span>65 9a 10 df ed 5f f3 8c 6a 7e 28 27 7d 90 34 57</span></li>
                                                                <li><span>Issued On: </span><span>Thu May 28 2020 16:56:18 GMT+0800 (å°åæ¨æºæé)</span></li>
                                                                <li><span>Expires On: </span><span>Fri May 28 2021 16:56:18 GMT+0800 (å°åæ¨æºæé)</span></li>
                                                                <li><span>SHA-256 Fingerprint: </span><span>f0 f5 bd 92 1b cc a9 c6 a8 cb 85 67 fd 90 74 fe 71 7a f6 1d 3b ad f4 fd dd 87 30 a4 76 f2 a6 3a</span></li>
                                                                <li><span>SHA-1 Fingerprint: </span><span>ba 24 16 cc ac 69 99 32 43 4d 80 c5 94 60 ff ef a3 10 94 da</span></li>
                                                            </ul>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <form>
                                    <div class="form-group">
                                        <textarea class="form-control certificate" id="certificate" rows="8" style="white-space: pre; visibility: hidden;" required="" autofocus="">-----BEGIN CERTIFICATE-----
MIIGQTCCBCmgAwIBAgIQZZoQ3+1f84xqfignfZA0VzANBgkqhkiG9w0BAQsFADCBhDELMAkGA1UEBhMCVFcxIzAhBgNVBAoTGkNodW5naHdhIFRlbGVjb20gQ28uLCBMdGQuMScwJQYDVQQLEx5GaW5hbmNpYWwgVUNBIGZvciBUZXN0aW5nIC0gRzQxJzAlBgNVBAMTHlRlc3QgVUNBIG9mIEZpbmFuY2lhbCBQS0kgLSBHNDAeFw0yMDA1MjgwODU2MThaFw0yMTA1MjgwODU2MThaMIGpMQswCQYDVQQGEwJUVzEjMCEGA1UECgwaQ2h1bmdId2EgVGVsZWNvbSBDby4sIEx0ZC4xLzAtBgNVBAsMJkZpbmFuY2lhbCBVc2VyIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MRswGQYDVQQLDBI4MDY5MDcyLVl1YW50YUJhbmsxDTALBgNVBAsMBEZYTUwxGDAWBgNVBAMMDzIwMjAwNTI4LS0wMDAwMTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAKrgyE7QRgFhDJ5koq9ot4e+xhH8WfY5cA5QGXG2uj3xaAMp4+ST9e8ClHsJ3TH21VCyHup0Oby31jbkfNfVTf/LRQiDMxGnpQeW0vzbKgI5vBgjTpTHRN9ojQp+APg45S5diEeJklZFwFU5WZtO6PKjoye22T2XJAnWUzW2l4rOxwftbmeAOMOa2q641D0oYzWTb8MWI76vPZFxtIyCpmXovVTgs0fOFqFztnkKQEr18yfpW9oVsKHmKI246OFDJ/1jOLX7Oga4P4fXjSCyB6ABiZD752g980kk0QflI0+RjgKM2ayku6ms6I8YcthWib0tLGxdolMAQptZbG2QfCUCAwEAAaOCAYYwggGCMH8GCCsGAQUFBwEBBHMwcTA9BggrBgEFBQcwAoYxaHR0cDovL3Rlc3RmY2EuaGluZXQubmV0L2NlcnRzL0lzc3VlZFRvVGhpc0NBLnA3YjAwBggrBgEFBQcwAYYkaHR0cDovL3Rlc3RmY2EuaGluZXQubmV0L09DU1Avb2NzcEc0MBQGA1UdIAQNMAswCQYHYIEeAwEDBTAOBgNVHQ8BAf8EBAMCBsAwKwYDVR0jBCQwIoAg2c9SjMGYrXoC2hTwWn+quhjNgG4H28IYXPfNQK2gmvUwKQYDVR0OBCIEIPdVZrvZQl08qk5wklq/wF4T99Gz1bCB+ccCOWGyAxAUMIGABgNVHR8EeTB3MD2gO6A5hjdodHRwOi8vdGVzdGZjYS5oaW5ldC5uZXQvY3JsL0ZVQ0FHNC8zMDA5LTEvY29tcGxldGUuY3JsMDagNKAyhjBodHRwOi8vdGVzdGZjYS5oaW5ldC5uZXQvY3JsL0ZVQ0FHNC9jb21wbGV0ZS5jcmwwDQYJKoZIhvcNAQELBQADggIBADz9KMQ9+oQYml+z1ehNs6e6FIOdQY0aucyW2CdtagqqOn0HWyLp+upulNOPnMi3Axq3PmZ8xWK5XSKRTVXbcRralEYlZmRSss/ErI7hYxAxu6n3uWwpUFGPFt55Ihw8+nIF3Wy8IAF3yryZLnr8pfQY2C1tpwdBgLOa/tO2Mo2l6qrcljf+RiQizydL42g3KO1RSh55+BKMMSZ8cubetJ1Fdfauyj+SbRasGqX3p4eF325RGbVLikOW53hXX1kJ933a423F2wR6ctilq5m/iDlbd7QDwJ14u6inmWtjGkg2FUuQXWj+onIjjqbNDwQGiqunxsMvKu9uYXNQYjwtpoonadxwEs3rHExu/8n9ggk5xiJGefhW7+nNKSnbO13kUh00wHIM9vOXffOP/3Ze6wW2J4qqK3k/CV+iqgBCZo7iewdT+KN8i75i1LyYceO4/bXlWm2xjUyLQX6lEkrK5vvsv5GnQB/v2EwqPtAJhJcwU5Qfk3vRN3m3LsW9AXXgZc+5gsgYjMtW9Jz2ajAPuWhUrMnGVo57bRyNEssFdftDXZCqleql3+J3SgyRObazbA93l/ws7Yc9tE/y1nSIziRDxy9TrYPKLRin/MKvASt90n2Sx7eU8nmnjKOnSCO/VwjpbBW+IUD099Zx1jb7ctBk77IDEbCZxWmNbzXHlazF
-----END CERTIFICATE-----</textarea>

                                        <div id="upload-error" class="alert alert-danger alert-dismissible mt-1" style="display: none; visibility: hidden;" role="alert">
                                            <small id="upload-error-message"></small>
                                            <button type="button" class="close" aria-label="Close" onclick="$(&#39;#upload-error&#39;).hide()">
                                                <span aria-hidden="true">Ã</span></button></div>
                                    </div>
                                    <div class="text-center">
                                        <div id="decode" style="visibility: hidden;">
                                            <button id="decode" type="submit" class="btn btn-primary btn-lg">Decode</button>
                                        </div>
                                        <div id="error" class="alert alert-danger alert-dismissible mt-2" style="" role="alert">
                                            <span id="error-message">ReferenceError: _dev is not defined</span>
                                            <button type="button" class="close" aria-label="Close" onclick="$(&#39;#error&#39;).hide()">
                                                <span aria-hidden="true">Ã</span></button>
                                        </div>
                                    </div>

                                    <div id="cert-info-warn" class="alert alert-warning mt-3" style="display: none;">
                                        <small>Certificate information will never leave your browser. Decoding happens
                                            using client-side JavaScript.</small>
                                    </div>
                                </form>

                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        var GTheader = 'R29UcnVzdC1JZGVtLVBLSQ=='; // GoTrust-Idem-PKI
        // 1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef  
        var signData =
            'MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWY=';
        //    1234567890abcdef1234567890abcdef
        var signShortData = 'MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWY=';


        document.getElementById('find-index').addEventListener('submit', function(event) {
            event.preventDefault();
            var pki_buffer = [];
            let certIndex = document.getElementById('use-index').certIndex.value;

            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);

            //Prepare PKI commmand
            //Header
            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));

            var pki_header = new Uint8Array(3);

            //PKI Command
            var command_bufer = new Uint8Array(4);
            command_bufer[0] = 0xDF;
            command_bufer[1] = 0x02;
            command_bufer[2] = 01;
            command_bufer[3] = certIndex;

            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_bufer.byteLength);
            var pki_payload_length = command_bufer.byteLength;
            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_header[0] = 0xE1;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_bufer), 3 + gtheaderbuffer.byteLength);

            console.log(bufToHex());

            var publicKey1 = {
                'challenge': challenge,

                'rp': {
                    'name': 'GoTrustID Inc.',
                },

                'user': {
                    'id': pki_buffer,
                    'name': 'Get Cert By Index',
                    'displayName': 'Get Cert By Index'
                },

                "authenticatorSelection": {
                    "requireResidentKey": false,
                    "authenticatorAttachment": "cross-platform"

                },
                'attestation': "none",
                'pubKeyCredParams': [{
                    'type': 'public-key',
                    'alg': -7
                }, {
                    'type': 'public-key',
                    'alg': -257
                }]
            }
            console.log('Search_by_Index:', publicKey1)


            navigator.credentials.create({
                    'publicKey': publicKey1
                })
                .then((newCredentialInfo) => {

                    console.log('SUCCESS', newCredentialInfo)
                    console.log('ClientDataJSON: ', bufferToString(newCredentialInfo.response
                        .clientDataJSON))
                    let attestationObject = CBOR.decode(newCredentialInfo.response.attestationObject);
                    console.log('AttestationObject: ', attestationObject)
                    let authData = parseAuthData(attestationObject.authData);
                    console.log('AuthData: ', authData);
                    console.log('CredID: ', bufToHex(authData.credID));
                    console.log('AAGUID: ', bufToHex(authData.aaguid));
                    console.log('PublicKey', CBOR.decode(authData.COSEPublicKey.buffer));
                    alert('Read certificate finished!')


                    const sliced = new Uint8Array(authData.credID.slice(1, authData.credID.length))
                    var strCert = "-----BEGIN CERTIFICATE-----\n" +
                        btoa(String.fromCharCode.apply(null, sliced)) +
                        "\n-----END CERTIFICATE-----"

                    console.log('Certificatie : \n', strCert)



                    displayCert(strCert)

                })
                .catch((error) => {
                    alert(error)
                    console.log('FAIL', error)
                })
        })
        document.getElementById('find-index-safari').addEventListener('submit', function(event) {
            event.preventDefault();
            var pki_buffer = [];
            let certIndex = document.getElementById('use-index-safari').certIndex.value;
            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);

            //Prepare PKI commmand
            //Header
            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));
            var pki_header = new Uint8Array(3);

            //PKI Command
            var command_bufer = new Uint8Array(4);
            command_bufer[0] = 0xDF;
            command_bufer[1] = 0x02;
            command_bufer[2] = 01;
            command_bufer[3] = certIndex;

            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_bufer.byteLength);
            var pki_payload_length = command_bufer.byteLength;
            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_header[0] = 0xE1;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_bufer), 3 + gtheaderbuffer.byteLength);

            console.log(bufToHex(pki_buffer));

            var publicKey1 = {
                'challenge': challenge,

                'rp': {
                    'name': 'GoTrustID Inc.',
                },

                'user': {
                    'id': pki_buffer,
                    'name': 'Get Cert By Index',
                    'displayName': 'Get Cert By Index'
                },

                "authenticatorSelection": {
                    "requireResidentKey": false,
                    "userVerification": "discouraged",
                    "authenticatorAttachment": "cross-platform"

                },
                'attestation': "none",
                'pubKeyCredParams': [{
                    'type': 'public-key',
                    'alg': -7
                }, {
                    'type': 'public-key',
                    'alg': -257
                }]
            }
            console.log('Search_by_Index on Safari:', bufToHex(publicKey1));


            navigator.credentials.create({
                    'publicKey': publicKey1
                })
                .then((newCredentialInfo) => {

                    console.log('SUCCESS', newCredentialInfo)
                    console.log('ClientDataJSON: ', bufferToString(newCredentialInfo.response
                        .clientDataJSON))
                    let attestationObject = CBOR.decode(newCredentialInfo.response.attestationObject);
                    console.log('AttestationObject: ', attestationObject)
                    let authData = parseAuthData(attestationObject.authData);
                    console.log('AuthData: ', authData);
                    console.log('CredID: ', bufToHex(authData.credID));
                    console.log('AAGUID: ', bufToHex(authData.aaguid));
                    console.log('PublicKey', CBOR.decode(authData.COSEPublicKey.buffer));
                    alert('Read certificate finished!');


                    const sliced = new Uint8Array(authData.credID.slice(1, authData.credID.length))
                    var strCert = "-----BEGIN CERTIFICATE-----\n" +
                        btoa(String.fromCharCode.apply(null, sliced)) +
                        "\n-----END CERTIFICATE-----"

                    console.log('Certificatie : \n', strCert)



                    displayCert(strCert)

                })
                .catch((error) => {
                    alert(error)
                    console.log('FAIL', error)
                })

        })
        document.getElementById('sign-byindex').addEventListener('submit', function(event) {
            event.preventDefault();
            var pki_buffer = [];
            let certIndex = document.getElementById('use-index').certIndex.value;

            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);
            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));

            var pki_header = new Uint8Array(3);

            //PKI Command
            var command_buf = new Uint8Array(4);
            command_buf[0] = 0xDF;
            command_buf[1] = 0x02;
            command_buf[2] = 01;
            command_buf[3] = certIndex;

            var alg_buf = new Uint8Array(4);
            alg_buf[0] = 0xDF;
            alg_buf[1] = 0x03;
            alg_buf[2] = 01;
            alg_buf[3] = 0x02;

            var signDataPayload = Uint8Array.from(window.atob(signData), c => c.charCodeAt(0));
            var signDataBuf = new Uint8Array(3 + signDataPayload.byteLength);
            signDataBuf[0] = 0xDF;
            signDataBuf[1] = 0x06;
            signDataBuf[2] = signDataPayload.length;
            signDataBuf.set(signDataPayload, 3);


            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_buf.byteLength + alg_buf
                .byteLength + signDataBuf.byteLength);
            var pki_payload_length = command_buf.byteLength + alg_buf.byteLength + signDataBuf.byteLength;
            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_header[0] = 0xE3;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_buf), gtheaderbuffer.byteLength + 3);
            pki_buffer.set(new Uint8Array(alg_buf), gtheaderbuffer.byteLength + 3 + command_buf.byteLength);
            pki_buffer.set(new Uint8Array(signDataBuf), gtheaderbuffer.byteLength + 3 + command_buf
                .byteLength + alg_buf.byteLength);

            console.log("sign-byindex", bufToHex(pki_buffer));
            var getAssertionChallenge = {
                'challenge': challenge,
            }
            var idList = [{
                id: pki_buffer,
                transports: ["usb", "nfc"],
                type: "public-key"
            }];

            getAssertionChallenge.allowCredentials = idList;
            console.log('List getAssertionChallenge', getAssertionChallenge)


            navigator.credentials.get({
                    'publicKey': getAssertionChallenge
                })
                .then((newCredentialInfo) => {
                    alert('Sign finished!')
                    console.log('SUCCESS', newCredentialInfo);
                    console.log("Sign", newCredentialInfo.response.signature);

                    const sign = newCredentialInfo.response.signature;
                    var str = String.fromCharCode.apply(null, new Uint8Array(sign));

                    document.getElementById('show-sign').value = "Data:" + "\n" + signData + "\n" +
                        "sign:" + "\n" + btoa(str);


                })
                .catch((error) => {
                    alert(error)
                    console.log('FAIL', error)
                })
        })

        document.getElementById('search-ckalabel').addEventListener('submit', function(event) {
            event.preventDefault();
            var pki_buffer = [];
            let ckaLabel = document.getElementById('use-label').ckaLabel.value;

            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);


            var pki_header = new Uint8Array(3);

            ///////////////////////////////////////////////////////////////
            var command_bufer = new Uint8Array(ckaLabel.length + 3);
            window.crypto.getRandomValues(command_bufer);
            command_bufer[0] = 0xDF
            command_bufer[1] = 0x01;

            command_bufer[2] = ckaLabel.length;
            command_bufer.set(toUTF8Array(ckaLabel), 3);

            console.log('CKAL length = ', ckaLabel.length);
            console.log('cmd_buf length = ', command_bufer.length);

            ///////////////////////////////////////////////////////////////

            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));

            console.log('GT_Header length = ', gtheaderbuffer.length);
            console.log('GT_Header = ', gtheaderbuffer);
            console.log('pki head length = ', pki_header.length)
            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + pki_header.byteLength + command_bufer
                .byteLength);
            var pki_payload_length = command_bufer.byteLength;

            pki_header[0] = 0xE0;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;

            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_bufer), gtheaderbuffer.byteLength + pki_header.byteLength);

            console.log(bufToHex(pki_buffer));

            var publicKey1 = {
                'challenge': challenge,

                'rp': {
                    'name': 'GoTrustID Inc.',
                },

                'user': {
                    'id': pki_buffer,
                    'name': 'Get Cert By Index',
                    'displayName': 'Get Cert By Label'
                },

                "authenticatorSelection": {
                    "requireResidentKey": false,
                    "authenticatorAttachment": "cross-platform"

                },
                'attestation': "none",
                'pubKeyCredParams': [{
                    'type': 'public-key',
                    'alg': -7
                }, {
                    'type': 'public-key',
                    'alg': -257
                }]
            }
            console.log('List publicKey1', publicKey1)


            navigator.credentials.create({
                    'publicKey': publicKey1
                })
                .then((newCredentialInfo) => {

                    console.log('SUCCESS', newCredentialInfo)
                    console.log('ClientDataJSON: ', bufferToString(newCredentialInfo.response
                        .clientDataJSON))
                    let attestationObject = CBOR.decode(newCredentialInfo.response.attestationObject);
                    console.log('AttestationObject: ', attestationObject);
                    let authData = parseAuthData(attestationObject.authData);
                    console.log('AuthData: ', authData);
                    console.log('AuthDLen: ', attestationObject.authData.length);
                    console.log('CredID: ', bufToHex(authData.credID));
                    console.log('CredIDLen: ', authData.credID.length);
                    console.log('AAGUID: ', bufToHex(authData.aaguid));
                    console.log('PublicKey', CBOR.decode(authData.COSEPublicKey.buffer));
                    alert('Read certificate finished!');

                    var strCert = "-----BEGIN CERTIFICATE-----\n" +
                        btoa(String.fromCharCode.apply(null, authData.credID)) +
                        "\n-----END CERTIFICATE-----"

                    console.log('Certificatie : \n', strCert)



                    displayCert(strCert)




                })
                .catch((error) => {
                    alert(error)
                    console.log('FAIL', error)
                })
        })

        document.getElementById('search-ckalabel-safari').addEventListener('submit', function(event) {
            event.preventDefault();
            var pki_buffer = [];
            let ckaLabel = document.getElementById('use-label-safari').ckaLabel.value;

            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);


            var pki_header = new Uint8Array(3);
            var command_bufer = new Uint8Array(ckaLabel.length + 3);
            window.crypto.getRandomValues(command_bufer);
            command_bufer[0] = 0xDF
            command_bufer[1] = 0x01;

            command_bufer[2] = ckaLabel.length;
            command_bufer.set(toUTF8Array(ckaLabel), 3);


            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));
            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + pki_header.byteLength + command_bufer
                .byteLength);
            var pki_payload_length = command_bufer.byteLength;

            pki_header[0] = 0xE0;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;

            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_bufer), gtheaderbuffer.byteLength + pki_header.byteLength);

            console.log(bufToHex(pki_buffer));

            var publicKey1 = {
                'challenge': challenge,

                'rp': {
                    'name': 'GoTrustID Inc.',
                },

                'user': {
                    'id': pki_buffer,
                    'name': 'Get Cert By Index',
                    'displayName': 'Get Cert By Label'
                },

                "authenticatorSelection": {
                    "requireResidentKey": false,
                    "userVerification": "discouraged",
                    "authenticatorAttachment": "cross-platform",


                },
                'attestation': "none",
                'pubKeyCredParams': [{
                    'type': 'public-key',
                    'alg': -7
                }, {
                    'type': 'public-key',
                    'alg': -257
                }]
            }
            console.log('search-ckalabel-safari', bufToHex(publicKey1));


            navigator.credentials.create({
                    'publicKey': publicKey1
                })
                .then((newCredentialInfo) => {

                    console.log('SUCCESS', newCredentialInfo)
                    console.log('ClientDataJSON: ', bufferToString(newCredentialInfo.response
                        .clientDataJSON))
                    let attestationObject = CBOR.decode(newCredentialInfo.response.attestationObject);
                    console.log('AttestationObject: ', attestationObject);
                    let authData = parseAuthData(attestationObject.authData);
                    console.log('AuthData: ', authData);
                    console.log('CredID: ', bufToHex(authData.credID));
                    console.log('AAGUID: ', bufToHex(authData.aaguid));
                    console.log('PublicKey', CBOR.decode(authData.COSEPublicKey.buffer));
                    alert('Read certificate finished!');

                    var strCert = "-----BEGIN CERTIFICATE-----\n" +
                        btoa(String.fromCharCode.apply(null, authData.credID)) +
                        "\n-----END CERTIFICATE-----"

                    console.log('Certificatie : \n', strCert)



                    displayCert(strCert)




                })
                .catch((error) => {
                    alert(error)
                    console.log('FAIL', error)
                })
        })

        document.getElementById('sign-byckalabel').addEventListener('submit', function(event) {
            event.preventDefault();
            var pki_buffer = [];
            let ckaLabel = document.getElementById('use-label').ckaLabel.value;

            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);
            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));

            var pki_header = new Uint8Array(3);

            //PKI Command
            var command_bufer = new Uint8Array(ckaLabel.length + 3);
            window.crypto.getRandomValues(command_bufer);
            command_bufer[0] = 0xDF
            command_bufer[1] = 0x01;
            command_bufer[2] = ckaLabel.length;
            command_bufer.set(toUTF8Array(ckaLabel), 3);


            var alg_buf = new Uint8Array(4);
            alg_buf[0] = 0xDF;
            alg_buf[1] = 0x03;
            alg_buf[2] = 01;
            alg_buf[3] = 0x02;

            var signDataPayload = Uint8Array.from(window.atob(signData), c => c.charCodeAt(0));
            var signDataBuf = new Uint8Array(3 + signDataPayload.byteLength);
            signDataBuf[0] = 0xDF;
            signDataBuf[1] = 0x06;
            signDataBuf[2] = signDataPayload.length;
            signDataBuf.set(signDataPayload, 3);


            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_bufer.byteLength + alg_buf
                .byteLength + signDataBuf.byteLength);
            var pki_payload_length = command_bufer.byteLength + alg_buf.byteLength + signDataBuf.byteLength;
            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_header[0] = 0xE2;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_bufer), gtheaderbuffer.byteLength + 3);
            pki_buffer.set(new Uint8Array(alg_buf), gtheaderbuffer.byteLength + 3 + command_bufer.byteLength);
            pki_buffer.set(new Uint8Array(signDataBuf), gtheaderbuffer.byteLength + 3 + command_bufer
                .byteLength + alg_buf.byteLength);

            console.log(bufToHex(pki_buffer));


            var getAssertionChallenge = {
                'challenge': challenge,
            }
            var idList = [{
                id: pki_buffer,
                transports: ["usb", "nfc"],
                type: "public-key"
            }];

            getAssertionChallenge.allowCredentials = idList;
            console.log('List getAssertionChallenge', getAssertionChallenge)


            navigator.credentials.get({
                    'publicKey': getAssertionChallenge
                })
                .then((newCredentialInfo) => {

                    console.log('SUCCESS', newCredentialInfo)
                    console.log("Sign", newCredentialInfo.response.signature)
                    const sign = newCredentialInfo.response.signature;
                    var str = String.fromCharCode.apply(null, new Uint8Array(sign));

                    document.getElementById('show-sign').value = "Data:" + "\n" + signData + "\n" +
                        "sign:" + "\n" + btoa(str);

                })
                .catch((error) => {
                    alert(error)
                    console.log('FAIL', error)
                })
        })

        document.getElementById('android-ckalabel-getassertion').addEventListener('submit', function(event) {
            event.preventDefault();

            let ckaLabel = document.getElementById('android-label').ckaLabel.value;
            let userpin = document.getElementById('android-ckalabel-pin').pin.value;
            console.log('android-label', ckaLabel);
            console.log('android-ckalabel-pin', userpin);

            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);
            var local_privateKey;
            var local_privateKey;
            var externalECPublicKey;
            var exportECPublicKeyArray;
            var pinEncKey;
            var EncryptedPINArray;

            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);


            var pki_header = new Uint8Array(3);
            var command_bufer = new Uint8Array(ckaLabel.length + 3);
            window.crypto.getRandomValues(command_bufer);
            command_bufer[0] = 0xDF
            command_bufer[1] = 0x01;
            command_bufer[2] = ckaLabel.length;
            command_bufer.set(toUTF8Array(ckaLabel), 3);


            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));
            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + pki_header.byteLength + command_bufer
                .byteLength);
            var pki_payload_length = command_bufer.byteLength;

            pki_header[0] = 0xE0;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;

            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_bufer), gtheaderbuffer.byteLength + pki_header.byteLength);

            console.log(bufToHex(pki_buffer));

            var safari_readecdh = {
                'challenge': challenge,

                'rp': {
                    'name': 'GoTrustID Inc.',
                },

                'user': {
                    'id': pki_buffer,
                    'name': 'alice@example.com',
                    'displayName': 'Alice von Wunderland'
                },

                "authenticatorSelection": {
                    "userVerification": "discouraged",
                    "requireResidentKey": false,
                    "authenticatorAttachment": "cross-platform"

                },
                'attestation': "direct",
                'pubKeyCredParams': [{
                    'type': 'public-key',
                    'alg': -7
                }, {
                    'type': 'public-key',
                    'alg': -257
                }]
            }
            console.log('Get ECDH Key', safari_readecdh);

            navigator.credentials.create({
                'publicKey': safari_readecdh
            }).then((newCredentialInfo) => {

                let attestationObject = CBOR.decode(newCredentialInfo.response.attestationObject);
                let authData = parseAuthData(attestationObject.authData);
                var publicKEy = CBOR.decode(authData.COSEPublicKey.buffer);
                console.log('X point: ', bufToHex(Object.values(publicKEy)[3]));
                console.log('Y point: ', bufToHex(Object.values(publicKEy)[4]));

                var externalECPublicKeyX = base64EncodeURL(Object.values(publicKEy)[3]);
                var externalECPublicKeyY = base64EncodeURL(Object.values(publicKEy)[4]);
                console.log("externalECPublicKeyX ", externalECPublicKeyX);
                console.log("externalECPublicKeyY", externalECPublicKeyY);


                return window.crypto.subtle.importKey(
                    "jwk", //can be "jwk" (public or private), "raw" (public only), "spki" (public only), or "pkcs8" (private only)
                    { //this is an example jwk key, other key types are Uint8Array objects
                        kty: "EC",
                        crv: "P-256",
                        x: externalECPublicKeyX,
                        y: externalECPublicKeyY,
                        ext: true,
                    }, { //these are the algorithm options
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    [] //"deriveKey" and/or "deriveBits" for private keys only (just put an empty list if importing a public key)
                );

            }).then(function(external_public) {
                //returns a privateKey (or publicKey if you are importing a public key)
                externalECPublicKey = external_public;
                console.log("external_public", externalECPublicKey);
                return window.crypto.subtle.generateKey({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    ["deriveKey",
                        "deriveBits"
                    ] //can be any combination of "deriveKey" and "deriveBits"
                );
            }).then(function(key) { //generate ecdh pair

                local_publicKey = key.publicKey;
                local_privateKey = key.privateKey;


                window.crypto.subtle.exportKey("raw", local_publicKey).then(
                    function(keydata) {
                        exportECPublicKeyArray = keydata;
                        console.log("local_publicKey", local_publicKey);
                        console.log("local_publicKey", bufToHex(local_publicKey));
                        console.log("exportECPublicKeyArray", bufToHex(exportECPublicKeyArray));
                    }
                );


                return window.crypto.subtle.deriveBits({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                        public: externalECPublicKey, //an ECDH public key from generateKey or importKey

                    },
                    local_privateKey, //from generateKey or importKey above
                    256 //the number of bits you want to derive
                );

            }).then(function(keybits) { //convert share secret to pinEncKey

                console.log('keybits ..............', keybits);
                console.log('Uint8Array(keybits)...', (new Uint8Array(keybits)));

                return crypto.subtle.digest(
                    "SHA-256",
                    new Uint8Array(keybits)
                );
            }).then(function(pinEncKeyBytes) {
                console.log("pinEncKeyBytes(original)...", pinEncKeyBytes);
                console.log("pinEncKeyBytes(buf2hex)....", bufToHex(pinEncKeyBytes));
                return crypto.subtle.importKey("raw",
                    pinEncKeyBytes,
                    "aes-cbc", false, ["encrypt"]);

            }).then(function(importKey) {
                pinEncKey = importKey;
                console.log("pinEncKey ", pinEncKey);
                const encoder = new TextEncoder();
                const data = encoder.encode(userpin);

                console.log("PIN data encoded...", data);

                return crypto.subtle.digest(
                    "SHA-256",
                    data);
            }).then(function(userpin_digestBytes) {
                console.log("userpin_digestBytes(original)", userpin_digestBytes);
                console.log("userpin_digestBytes(buf2Hex )", bufToHex(userpin_digestBytes.slice(0, 16)));
                var iv = new Uint8Array(16);
                console.log("iv .... ", iv);

                return crypto.subtle.encrypt({
                    name: "aes-cbc",
                    iv
                }, pinEncKey, userpin_digestBytes.slice(0, 16));
            }).then(function(cipherPIN) { // start get assertion

                console.log("cipherPIN(original)", cipherPIN);

                EncryptedPINArray = cipherPIN.slice(0, 16);

                console.log("EncryptedPINArray", bufToHex(EncryptedPINArray.slice(0, 16)));
                var enc = new TextEncoder();
                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));



                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));

                var pki_header = new Uint8Array(3);

                //PKI Command
                var command_buf = new Uint8Array(ckaLabel.length + 3);
                command_buf[0] = 0xDF
                command_buf[1] = 0x01;
                command_buf[2] = ckaLabel.length;
                command_buf.set(toUTF8Array(ckaLabel), 3);



                var alg_buf = new Uint8Array(4);
                alg_buf[0] = 0xDF;
                alg_buf[1] = 0x03;
                alg_buf[2] = 01;
                alg_buf[3] = 0x02;


                var ecpubkey_buf = new Uint8Array(3 + exportECPublicKeyArray.byteLength);
                ecpubkey_buf[0] = 0xDF;
                ecpubkey_buf[1] = 0x04;
                ecpubkey_buf[2] = exportECPublicKeyArray.byteLength;
                ecpubkey_buf.set(new Uint8Array(exportECPublicKeyArray), 3);


                var encryptedPIN_buf = new Uint8Array(3 + EncryptedPINArray.byteLength);
                encryptedPIN_buf[0] = 0xDF;
                encryptedPIN_buf[1] = 0x05;
                encryptedPIN_buf[2] = EncryptedPINArray.byteLength;
                encryptedPIN_buf.set(new Uint8Array(EncryptedPINArray), 3);

                var signDataPayload = Uint8Array.from(window.atob(signShortData), c => c.charCodeAt(0));
                var signDataBuf = new Uint8Array(3 + signDataPayload.byteLength);
                signDataBuf[0] = 0xDF;
                signDataBuf[1] = 0x06;
                signDataBuf[2] = signDataPayload.length;
                signDataBuf.set(signDataPayload, 3);



                var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_buf.byteLength +
                    alg_buf.byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf.byteLength +
                    signDataBuf.byteLength);
                var pki_payload_length = command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf
                    .byteLength + encryptedPIN_buf.byteLength + signDataBuf.byteLength;
                pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
                pki_header[0] = 0xE4;
                pki_header[1] = pki_payload_length >> 8
                pki_header[2] = pki_payload_length;
                pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
                pki_buffer.set(new Uint8Array(command_buf), gtheaderbuffer.byteLength + 3);
                pki_buffer.set(new Uint8Array(alg_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength);
                pki_buffer.set(new Uint8Array(ecpubkey_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength);
                pki_buffer.set(new Uint8Array(encryptedPIN_buf), gtheaderbuffer.byteLength + 3 +
                    command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength);
                pki_buffer.set(new Uint8Array(signDataBuf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf
                    .byteLength);

                console.log("sign-ckalabel-android: " + bufToHex(pki_buffer));

                var getAssertionChallenge = {
                    'challenge': challenge,
                    "userVerification": "discouraged"
                }
                var idList = [{
                    id: pki_buffer,
                    transports: ["usb", "nfc"],
                    type: "public-key"
                }];

                getAssertionChallenge.allowCredentials = idList;
                console.log('List getAssertionChallenge', getAssertionChallenge)

                navigator.credentials.get({
                    'publicKey': getAssertionChallenge
                }).then((newCredentialInfo) => {

                    alert('Sign finished');
                    console.log('SUCCESS', newCredentialInfo)
                    console.log("Sign", newCredentialInfo.response.signature)
                    const sign = newCredentialInfo.response.signature;

                    if (sign.byteLength < 256) {
                        navigator.credentials.get({
                                'publicKey': getAssertionChallenge
                            }).then((newCredentialInfo) => {

                                alert('Sign finished');
                                console.log('SUCCESS', newCredentialInfo)
                                console.log("Sign", newCredentialInfo.response.signature)
                                const sign = newCredentialInfo.response.signature;
                                var str = String.fromCharCode.apply(null, new Uint8Array(
                                    sign));

                                document.getElementById('show-sign').value = "Data:" +
                                    "\n" + signData +
                                    "\n" +
                                    "sign:" + "\n" + btoa(str);
                            })
                            .catch((error) => {
                                alert(error)
                                console.log('FAIL', error)

                            })
                    } else {
                        document.getElementById('show-sign').value = "Data:" +
                            "\n" + signData +
                            "\n" +
                            "sign:" + "\n" + btoa(str);
                    }

                });

            });
        })


        document.getElementById('android-index-getassertion').addEventListener('submit', function(event) {
            event.preventDefault();


            let certIndex = document.getElementById('android-index').certIndex.value;
            let userpin = document.getElementById('android-index-pin').pin.value;


            console.log('android-index', certIndex);
            console.log('android-index-pin', userpin);

            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);
            var local_privateKey;
            var local_privateKey;
            var externalECPublicKey;
            var exportECPublicKeyArray;
            var pinEncKey;
            var EncryptedPINArray;

            //Prepare PKI commmand
            //Header
            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));
            var pki_header = new Uint8Array(3);

            //PKI Command
            var command_bufer = new Uint8Array(4);
            command_bufer[0] = 0xDF;
            command_bufer[1] = 0x02;
            command_bufer[2] = 01;
            command_bufer[3] = certIndex;

            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_bufer.byteLength);
            var pki_payload_length = command_bufer.byteLength;
            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_header[0] = 0xE1;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_bufer), 3 + gtheaderbuffer.byteLength);

            console.log(bufToHex(pki_buffer));

            var android_readecdh = {
                'challenge': challenge,

                'rp': {
                    'name': 'GoTrustID Inc.',
                },

                'user': {
                    'id': pki_buffer,
                    'name': 'alice@example.com',
                    'displayName': 'Alice von Wunderland'
                },

                "authenticatorSelection": {
                    "userVerification": "discouraged",
                    "requireResidentKey": false,
                    "authenticatorAttachment": "cross-platform"

                },
                'attestation': "direct",
                'pubKeyCredParams': [{
                    'type': 'public-key',
                    'alg': -7
                }, {
                    'type': 'public-key',
                    'alg': -257
                }]
            }
            console.log('Get ECDH Key', android_readecdh);

            navigator.credentials.create({
                'publicKey': android_readecdh
            }).then((newCredentialInfo) => {

                let attestationObject = CBOR.decode(newCredentialInfo.response.attestationObject);
                let authData = parseAuthData(attestationObject.authData);
                var publicKEy = CBOR.decode(authData.COSEPublicKey.buffer);
                console.log('X point: ', bufToHex(Object.values(publicKEy)[3]));
                console.log('Y point: ', bufToHex(Object.values(publicKEy)[4]));

                var externalECPublicKeyX = base64EncodeURL(Object.values(publicKEy)[3]);
                var externalECPublicKeyY = base64EncodeURL(Object.values(publicKEy)[4]);
                console.log("externalECPublicKeyX ", externalECPublicKeyX);
                console.log("externalECPublicKeyY", externalECPublicKeyY);
                return window.crypto.subtle.importKey(
                    "jwk", //can be "jwk" (public or private), "raw" (public only), "spki" (public only), or "pkcs8" (private only)
                    { //this is an example jwk key, other key types are Uint8Array objects
                        kty: "EC",
                        crv: "P-256",
                        x: externalECPublicKeyX,
                        y: externalECPublicKeyY,
                        ext: true,
                    }, { //these are the algorithm options
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    [] //"deriveKey" and/or "deriveBits" for private keys only (just put an empty list if importing a public key)
                );

            }).then(function(external_public) {
                //returns a privateKey (or publicKey if you are importing a public key)
                externalECPublicKey = external_public;
                console.log("external_public", externalECPublicKey);
                return window.crypto.subtle.generateKey({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    ["deriveKey",
                        "deriveBits"
                    ] //can be any combination of "deriveKey" and "deriveBits"
                );
            }).then(function(key) { //generate ecdh pair

                local_publicKey = key.publicKey;
                local_privateKey = key.privateKey;


                window.crypto.subtle.exportKey("raw", local_publicKey).then(
                    function(keydata) {
                        exportECPublicKeyArray = keydata;
                        console.log("exportECPublicKeyArray", bufToHex(exportECPublicKeyArray));
                    }
                );


                return window.crypto.subtle.deriveBits({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                        public: externalECPublicKey, //an ECDH public key from generateKey or importKey

                    },
                    local_privateKey, //from generateKey or importKey above
                    256 //the number of bits you want to derive
                );

            }).then(function(keybits) { //convert share secret to pinEncKey
                return crypto.subtle.digest(
                    "SHA-256",
                    new Uint8Array(keybits)
                );
            }).then(function(pinEncKeyBytes) {
                console.log("pinEncKeyBytes", bufToHex(pinEncKeyBytes));
                return crypto.subtle.importKey("raw",
                    pinEncKeyBytes,
                    "aes-cbc", false, ["encrypt"]);

            }).then(function(importKey) {
                pinEncKey = importKey;
                console.log("pinEncKey ", pinEncKey);
                const encoder = new TextEncoder();
                const data = encoder.encode(userpin);
                return crypto.subtle.digest(
                    "SHA-256",
                    data);
            }).then(function(userpin_digestBytes) {
                console.log("userpin_digestBytes", bufToHex(userpin_digestBytes.slice(0, 16)));
                var iv = new Uint8Array(16);
                console.log("iv .... ", iv);

                return crypto.subtle.encrypt({
                    name: "aes-cbc",
                    iv
                }, pinEncKey, userpin_digestBytes.slice(0, 16));
            }).then(function(cipherPIN) { // start get assertion

                EncryptedPINArray = cipherPIN.slice(0, 16);

                console.log("EncryptedPINArray", bufToHex(EncryptedPINArray.slice(0, 16)));
                var enc = new TextEncoder();
                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));



                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));

                var pki_header = new Uint8Array(3);

                //PKI Command
                var command_buf = new Uint8Array(4);
                command_buf[0] = 0xDF;
                command_buf[1] = 0x02;
                command_buf[2] = 01;
                command_buf[3] = certIndex;

                var alg_buf = new Uint8Array(4);
                alg_buf[0] = 0xDF;
                alg_buf[1] = 0x03;
                alg_buf[2] = 01;
                alg_buf[3] = 0x02;


                var ecpubkey_buf = new Uint8Array(3 + exportECPublicKeyArray.byteLength);
                ecpubkey_buf[0] = 0xDF;
                ecpubkey_buf[1] = 0x04;
                ecpubkey_buf[2] = exportECPublicKeyArray.byteLength;
                ecpubkey_buf.set(new Uint8Array(exportECPublicKeyArray), 3);


                var encryptedPIN_buf = new Uint8Array(3 + EncryptedPINArray.byteLength);
                encryptedPIN_buf[0] = 0xDF;
                encryptedPIN_buf[1] = 0x05;
                encryptedPIN_buf[2] = EncryptedPINArray.byteLength;
                encryptedPIN_buf.set(new Uint8Array(EncryptedPINArray), 3);

                var signDataPayload = Uint8Array.from(window.atob(signShortData), c => c.charCodeAt(0));
                var signDataBuf = new Uint8Array(3 + signDataPayload.byteLength);
                signDataBuf[0] = 0xDF;
                signDataBuf[1] = 0x06;
                signDataBuf[2] = signDataPayload.length;
                signDataBuf.set(signDataPayload, 3);



                var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_buf.byteLength +
                    alg_buf
                    .byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf.byteLength +
                    signDataBuf.byteLength);
                var pki_payload_length = command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf
                    .byteLength + encryptedPIN_buf.byteLength + signDataBuf.byteLength;
                pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
                pki_header[0] = 0xE5;
                pki_header[1] = pki_payload_length >> 8
                pki_header[2] = pki_payload_length;
                pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
                pki_buffer.set(new Uint8Array(command_buf), gtheaderbuffer.byteLength + 3);
                pki_buffer.set(new Uint8Array(alg_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength);
                pki_buffer.set(new Uint8Array(ecpubkey_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength);
                pki_buffer.set(new Uint8Array(encryptedPIN_buf), gtheaderbuffer.byteLength + 3 +
                    command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength);
                pki_buffer.set(new Uint8Array(signDataBuf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf
                    .byteLength);

                console.log("sign-index-safari: " + bufToHex(pki_buffer));

                var getAssertionChallenge = {
                    'challenge': challenge,
                    "userVerification": "discouraged",
                    'timeout': "2000",
                }
                var idList = [{
                    id: pki_buffer,
                    transports: ["usb", "nfc"],
                    type: "public-key"
                }];

                getAssertionChallenge.allowCredentials = idList;
                console.log('List getAssertionChallenge', getAssertionChallenge)

                navigator.credentials.get({
                    'publicKey': getAssertionChallenge
                }).then((newCredentialInfo) => {
                    const sign1 = newCredentialInfo.response.signature;
                    if (sign1.byteLength < 251) {

                        console.log('List sign', android_readecdh)
                        navigator.credentials.create({
                                'publicKey': android_readecdh
                            }).then((newCredentialInfo) => {

                                alert('Sign finished');
                                let attestationObject = CBOR.decode(newCredentialInfo
                                    .response.attestationObject);
                                let authData = parseAuthData(attestationObject.authData);
                                var CredID = authData.credID;
                                var publicKEy = CBOR.decode(authData.COSEPublicKey.buffer);
                                var externalECPublicKeyX = base64EncodeURL(Object.values(
                                    publicKEy)[3]);
                                var sig_buffer = new Uint8Array(256);
                                sig_buffer[0] = externalECPublicKeyX[0];
                                sig_buffer.set(new Uint8Array(CredID), 1);
                                var str = String.fromCharCode.apply(null, new Uint8Array(
                                    sig_buffer));
                                document.getElementById('show-sign').value = "Data:" +
                                    "\n" + signData +
                                    "\n" +
                                    "sign:" + "\n" + btoa(str);

                            })
                            .catch((error) => {
                                alert(error)
                                console.log('FAIL', error)
                            })
                    } else {

                        alert('Sign finished');
                        console.log('SUCCESS', newCredentialInfo);
                        console.log("Sign", newCredentialInfo.response.signature);
                        const sign1 = newCredentialInfo.response.signature;


                        var str = String.fromCharCode.apply(null, new Uint8Array(
                            sign1));
                        document.getElementById('show-sign').value = "Data:" +
                            "\n" + signData +
                            "\n" +
                            "sign:" + "\n" + btoa(str);
                    }

                });

            });
        })




        document.getElementById('sign-index-safari').addEventListener('submit', function(event) {
            event.preventDefault();


            let certIndex = document.getElementById('use-index-safari').certIndex.value;
            let userpin = document.getElementById('safari-pin-index').pin.value;


            console.log('use-index-safari', certIndex);
            console.log('safari-pin-index', userpin);

            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);
            var local_privateKey;
            var local_privateKey;
            var externalECPublicKey;
            var exportECPublicKeyArray;
            var pinEncKey;
            var EncryptedPINArray;

            //Prepare PKI commmand
            //Header
            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));
            var pki_header = new Uint8Array(3);

            //PKI Command
            var command_bufer = new Uint8Array(4);
            command_bufer[0] = 0xDF;
            command_bufer[1] = 0x02;
            command_bufer[2] = 01;
            command_bufer[3] = certIndex;

            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_bufer.byteLength);
            var pki_payload_length = command_bufer.byteLength;
            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_header[0] = 0xE1;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_bufer), 3 + gtheaderbuffer.byteLength);

            console.log(bufToHex(pki_buffer));

            var safari_readecdh = {
                'challenge': challenge,

                'rp': {
                    'name': 'GoTrustID Inc.',
                },

                'user': {
                    'id': pki_buffer,
                    'name': 'alice@example.com',
                    'displayName': 'Alice von Wunderland'
                },

                "authenticatorSelection": {
                    "userVerification": "discouraged",
                    "requireResidentKey": false,
                    "authenticatorAttachment": "cross-platform"

                },
                'attestation': "direct",
                'pubKeyCredParams': [{
                    'type': 'public-key',
                    'alg': -7
                }, {
                    'type': 'public-key',
                    'alg': -257
                }]
            }
            console.log('Get ECDH Key', safari_readecdh);

            navigator.credentials.create({
                'publicKey': safari_readecdh
            }).then((newCredentialInfo) => {

                let attestationObject = CBOR.decode(newCredentialInfo.response.attestationObject);
                let authData = parseAuthData(attestationObject.authData);
                var publicKEy = CBOR.decode(authData.COSEPublicKey.buffer);
                console.log('X point: ', bufToHex(Object.values(publicKEy)[3]));
                console.log('Y point: ', bufToHex(Object.values(publicKEy)[4]));

                var externalECPublicKeyX = base64EncodeURL(Object.values(publicKEy)[3]);
                var externalECPublicKeyY = base64EncodeURL(Object.values(publicKEy)[4]);
                console.log("externalECPublicKeyX ", externalECPublicKeyX);
                console.log("externalECPublicKeyY", externalECPublicKeyY);
                return window.crypto.subtle.importKey(
                    "jwk", //can be "jwk" (public or private), "raw" (public only), "spki" (public only), or "pkcs8" (private only)
                    { //this is an example jwk key, other key types are Uint8Array objects
                        kty: "EC",
                        crv: "P-256",
                        x: externalECPublicKeyX,
                        y: externalECPublicKeyY,
                        ext: true,
                    }, { //these are the algorithm options
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    [] //"deriveKey" and/or "deriveBits" for private keys only (just put an empty list if importing a public key)
                );

            }).then(function(external_public) {
                //returns a privateKey (or publicKey if you are importing a public key)
                externalECPublicKey = external_public;
                console.log("external_public", externalECPublicKey);
                return window.crypto.subtle.generateKey({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    ["deriveKey",
                        "deriveBits"
                    ] //can be any combination of "deriveKey" and "deriveBits"
                );
            }).then(function(key) { //generate ecdh pair

                local_publicKey = key.publicKey;
                local_privateKey = key.privateKey;


                window.crypto.subtle.exportKey("raw", local_publicKey).then(
                    function(keydata) {
                        exportECPublicKeyArray = keydata;
                        console.log("exportECPublicKeyArray", bufToHex(exportECPublicKeyArray));
                    }
                );


                return window.crypto.subtle.deriveBits({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                        public: externalECPublicKey, //an ECDH public key from generateKey or importKey

                    },
                    local_privateKey, //from generateKey or importKey above
                    256 //the number of bits you want to derive
                );

            }).then(function(keybits) { //convert share secret to pinEncKey
                return crypto.subtle.digest(
                    "SHA-256",
                    new Uint8Array(keybits)
                );
            }).then(function(pinEncKeyBytes) {
                console.log("pinEncKeyBytes", bufToHex(pinEncKeyBytes));
                return crypto.subtle.importKey("raw",
                    pinEncKeyBytes,
                    "aes-cbc", false, ["encrypt"]);

            }).then(function(importKey) {
                pinEncKey = importKey;
                console.log("pinEncKey ", pinEncKey);
                const encoder = new TextEncoder();
                const data = encoder.encode(userpin);
                return crypto.subtle.digest(
                    "SHA-256",
                    data);
            }).then(function(userpin_digestBytes) {
                console.log("userpin_digestBytes", bufToHex(userpin_digestBytes.slice(0, 16)));
                var iv = new Uint8Array(16);
                console.log("iv .... ", iv);

                return crypto.subtle.encrypt({
                    name: "aes-cbc",
                    iv
                }, pinEncKey, userpin_digestBytes.slice(0, 16));
            }).then(function(cipherPIN) { // start get assertion

                EncryptedPINArray = cipherPIN.slice(0, 16);

                console.log("EncryptedPINArray", bufToHex(EncryptedPINArray.slice(0, 16)));
                var enc = new TextEncoder();
                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));



                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));

                var pki_header = new Uint8Array(3);

                //PKI Command
                var command_buf = new Uint8Array(4);
                command_buf[0] = 0xDF;
                command_buf[1] = 0x02;
                command_buf[2] = 01;
                command_buf[3] = certIndex;

                var alg_buf = new Uint8Array(4);
                alg_buf[0] = 0xDF;
                alg_buf[1] = 0x03;
                alg_buf[2] = 01;
                alg_buf[3] = 0x02;


                var ecpubkey_buf = new Uint8Array(3 + exportECPublicKeyArray.byteLength);
                ecpubkey_buf[0] = 0xDF;
                ecpubkey_buf[1] = 0x04;
                ecpubkey_buf[2] = exportECPublicKeyArray.byteLength;
                ecpubkey_buf.set(new Uint8Array(exportECPublicKeyArray), 3);


                var encryptedPIN_buf = new Uint8Array(3 + EncryptedPINArray.byteLength);
                encryptedPIN_buf[0] = 0xDF;
                encryptedPIN_buf[1] = 0x05;
                encryptedPIN_buf[2] = EncryptedPINArray.byteLength;
                encryptedPIN_buf.set(new Uint8Array(EncryptedPINArray), 3);

                var signDataPayload = Uint8Array.from(window.atob(signData), c => c.charCodeAt(0));
                var signDataBuf = new Uint8Array(3 + signDataPayload.byteLength);
                signDataBuf[0] = 0xDF;
                signDataBuf[1] = 0x06;
                signDataBuf[2] = signDataPayload.length;
                signDataBuf.set(signDataPayload, 3);



                var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_buf.byteLength +
                    alg_buf
                    .byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf.byteLength +
                    signDataBuf.byteLength);
                var pki_payload_length = command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf
                    .byteLength + encryptedPIN_buf.byteLength + signDataBuf.byteLength;
                pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
                pki_header[0] = 0xE5;
                pki_header[1] = pki_payload_length >> 8
                pki_header[2] = pki_payload_length;
                pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
                pki_buffer.set(new Uint8Array(command_buf), gtheaderbuffer.byteLength + 3);
                pki_buffer.set(new Uint8Array(alg_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength);
                pki_buffer.set(new Uint8Array(ecpubkey_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength);
                pki_buffer.set(new Uint8Array(encryptedPIN_buf), gtheaderbuffer.byteLength + 3 +
                    command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength);
                pki_buffer.set(new Uint8Array(signDataBuf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf
                    .byteLength);

                console.log("sign-index-safari: " + bufToHex(pki_buffer));

                var getAssertionChallenge = {
                    'challenge': challenge,
                    "userVerification": "discouraged"
                }
                var idList = [{
                    id: pki_buffer,
                    transports: ["usb", "nfc"],
                    type: "public-key"
                }];

                getAssertionChallenge.allowCredentials = idList;
                console.log('List getAssertionChallenge', getAssertionChallenge)

                navigator.credentials.get({
                        'publicKey': getAssertionChallenge
                    })
                    .then((newCredentialInfo) => {

                        console.log('SUCCESS', newCredentialInfo)
                        console.log("Sign", newCredentialInfo.response.signature)
                        const sign = newCredentialInfo.response.signature;
                        var str = String.fromCharCode.apply(null, new Uint8Array(sign));

                        document.getElementById('show-sign').value = "Data:" + "\n" + signData +
                            "\n" +
                            "sign:" + "\n" + btoa(str);

                    })
                    .catch((error) => {
                        alert(error)
                        console.log('FAIL', error)
                    })

            });
        })


        function base64EncodeURL(byteArray) {
            return btoa(Array.from(new Uint8Array(byteArray)).map(val => {
                return String.fromCharCode(val);
            }).join('')).replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
        };

        function toUTF8Array(str) {

            var utf8 = [];
            for (var i = 0; i < str.length; i++) {
                var charcode = str.charCodeAt(i);
                if (charcode < 0x80) utf8.push(charcode);
                else if (charcode < 0x800) {
                    utf8.push(0xc0 | (charcode >> 6),
                        0x80 | (charcode & 0x3f));
                } else if (charcode < 0xd800 || charcode >= 0xe000) {
                    utf8.push(0xe0 | (charcode >> 12),
                        0x80 | ((charcode >> 6) & 0x3f),
                        0x80 | (charcode & 0x3f));
                }
                // surrogate pair
                else {
                    i++;
                    // UTF-16 encodes 0x10000-0x10FFFF by
                    // subtracting 0x10000 and splitting the
                    // 20 bits of 0x0-0xFFFFF into two halves
                    charcode = 0x10000 + (((charcode & 0x3ff) << 10) |
                        (str.charCodeAt(i) & 0x3ff));
                    utf8.push(0xf0 | (charcode >> 18),
                        0x80 | ((charcode >> 12) & 0x3f),
                        0x80 | ((charcode >> 6) & 0x3f),
                        0x80 | (charcode & 0x3f));
                }
            }
            return utf8;
        }

        document.getElementById('sign-ckalabel-safari').addEventListener('submit', function(event) {
            event.preventDefault();


            let ckaLabel = document.getElementById('use-label-safari').ckaLabel.value;
            let userpin = document.getElementById('safari-pin-label').pin.value;


            console.log('use-label-safari', ckaLabel);
            console.log('safari-pin-label', userpin);

            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);
            var local_privateKey;
            var local_privateKey;
            var externalECPublicKey;
            var exportECPublicKeyArray;
            var pinEncKey;
            var EncryptedPINArray;

            var challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);


            var pki_header = new Uint8Array(3);
            var command_bufer = new Uint8Array(ckaLabel.length + 3);
            window.crypto.getRandomValues(command_bufer);
            command_bufer[0] = 0xDF
            command_bufer[1] = 0x01;
            command_bufer[2] = ckaLabel.length;
            command_bufer.set(toUTF8Array(ckaLabel), 3);


            var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));
            var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + pki_header.byteLength + command_bufer
                .byteLength);
            var pki_payload_length = command_bufer.byteLength;

            pki_header[0] = 0xE0;
            pki_header[1] = pki_payload_length >> 8
            pki_header[2] = pki_payload_length;

            pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
            pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
            pki_buffer.set(new Uint8Array(command_bufer), gtheaderbuffer.byteLength + pki_header.byteLength);

            console.log(bufToHex(pki_buffer));

            var safari_readecdh = {
                'challenge': challenge,

                'rp': {
                    'name': 'GoTrustID Inc.',
                },

                'user': {
                    'id': pki_buffer,
                    'name': 'alice@example.com',
                    'displayName': 'Alice von Wunderland'
                },

                "authenticatorSelection": {
                    "userVerification": "discouraged",
                    "requireResidentKey": false,
                    "authenticatorAttachment": "cross-platform"

                },
                'attestation': "direct",
                'pubKeyCredParams': [{
                    'type': 'public-key',
                    'alg': -7
                }, {
                    'type': 'public-key',
                    'alg': -257
                }]
            }
            console.log('Get ECDH Key', safari_readecdh);

            navigator.credentials.create({
                'publicKey': safari_readecdh
            }).then((newCredentialInfo) => {

                let attestationObject = CBOR.decode(newCredentialInfo.response.attestationObject);
                let authData = parseAuthData(attestationObject.authData);
                var publicKEy = CBOR.decode(authData.COSEPublicKey.buffer);
                console.log('X point: ', bufToHex(Object.values(publicKEy)[3]));
                console.log('Y point: ', bufToHex(Object.values(publicKEy)[4]));

                var externalECPublicKeyX = base64EncodeURL(Object.values(publicKEy)[3]);
                var externalECPublicKeyY = base64EncodeURL(Object.values(publicKEy)[4]);
                console.log("externalECPublicKeyX ", externalECPublicKeyX);
                console.log("externalECPublicKeyY", externalECPublicKeyY);


                return window.crypto.subtle.importKey(
                    "jwk", //can be "jwk" (public or private), "raw" (public only), "spki" (public only), or "pkcs8" (private only)
                    { //this is an example jwk key, other key types are Uint8Array objects
                        kty: "EC",
                        crv: "P-256",
                        x: externalECPublicKeyX,
                        y: externalECPublicKeyY,
                        ext: true,
                    }, { //these are the algorithm options
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    [] //"deriveKey" and/or "deriveBits" for private keys only (just put an empty list if importing a public key)
                );

            }).then(function(external_public) {
                //returns a privateKey (or publicKey if you are importing a public key)
                externalECPublicKey = external_public;
                console.log("external_public", externalECPublicKey);
                return window.crypto.subtle.generateKey({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                    },
                    true, //whether the key is extractable (i.e. can be used in exportKey)
                    ["deriveKey",
                        "deriveBits"
                    ] //can be any combination of "deriveKey" and "deriveBits"
                );
            }).then(function(key) { //generate ecdh pair

                local_publicKey = key.publicKey;
                local_privateKey = key.privateKey;


                window.crypto.subtle.exportKey("raw", local_publicKey).then(
                    function(keydata) {
                        exportECPublicKeyArray = keydata;
                        console.log("exportECPublicKeyArray", bufToHex(exportECPublicKeyArray));
                    }
                );


                return window.crypto.subtle.deriveBits({
                        name: "ECDH",
                        namedCurve: "P-256", //can be "P-256", "P-384", or "P-521"
                        public: externalECPublicKey, //an ECDH public key from generateKey or importKey

                    },
                    local_privateKey, //from generateKey or importKey above
                    256 //the number of bits you want to derive
                );

            }).then(function(keybits) { //convert share secret to pinEncKey
                return crypto.subtle.digest(
                    "SHA-256",
                    new Uint8Array(keybits)
                );
            }).then(function(pinEncKeyBytes) {
                console.log("pinEncKeyBytes", bufToHex(pinEncKeyBytes));
                return crypto.subtle.importKey("raw",
                    pinEncKeyBytes,
                    "aes-cbc", false, ["encrypt"]);

            }).then(function(importKey) {
                pinEncKey = importKey;
                console.log("pinEncKey ", pinEncKey);
                const encoder = new TextEncoder();
                const data = encoder.encode(userpin);
                return crypto.subtle.digest(
                    "SHA-256",
                    data);
            }).then(function(userpin_digestBytes) {
                console.log("userpin_digestBytes", bufToHex(userpin_digestBytes.slice(0, 16)));
                var iv = new Uint8Array(16);
                console.log("iv .... ", iv);

                return crypto.subtle.encrypt({
                    name: "aes-cbc",
                    iv
                }, pinEncKey, userpin_digestBytes.slice(0, 16));
            }).then(function(cipherPIN) { // start get assertion

                EncryptedPINArray = cipherPIN.slice(0, 16);

                console.log("EncryptedPINArray", bufToHex(EncryptedPINArray.slice(0, 16)));
                var enc = new TextEncoder();

                var pki_buffer = [];
                var challenge = new Uint8Array(32);
                window.crypto.getRandomValues(challenge);
                var gtheaderbuffer = Uint8Array.from(window.atob(GTheader), c => c.charCodeAt(0));

                var pki_header = new Uint8Array(3);

                //PKI Command
                var command_buf = new Uint8Array(ckaLabel.length + 3);
                command_buf[0] = 0xDF
                command_buf[1] = 0x01;
                command_buf[2] = ckaLabel.length;
                command_buf.set(toUTF8Array(ckaLabel), 3);



                var alg_buf = new Uint8Array(4);
                alg_buf[0] = 0xDF;
                alg_buf[1] = 0x03;
                alg_buf[2] = 01;
                alg_buf[3] = 0x02;


                var ecpubkey_buf = new Uint8Array(3 + exportECPublicKeyArray.byteLength);
                ecpubkey_buf[0] = 0xDF;
                ecpubkey_buf[1] = 0x04;
                ecpubkey_buf[2] = exportECPublicKeyArray.byteLength;
                ecpubkey_buf.set(new Uint8Array(exportECPublicKeyArray), 3);


                var encryptedPIN_buf = new Uint8Array(3 + EncryptedPINArray.byteLength);
                encryptedPIN_buf[0] = 0xDF;
                encryptedPIN_buf[1] = 0x05;
                encryptedPIN_buf[2] = EncryptedPINArray.byteLength;
                encryptedPIN_buf.set(new Uint8Array(EncryptedPINArray), 3);

                var signDataPayload = Uint8Array.from(window.atob(signData), c => c.charCodeAt(0));
                var signDataBuf = new Uint8Array(3 + signDataPayload.byteLength);
                signDataBuf[0] = 0xDF;
                signDataBuf[1] = 0x06;
                signDataBuf[2] = signDataPayload.length;
                signDataBuf.set(signDataPayload, 3);



                var pki_buffer = new Uint8Array(gtheaderbuffer.byteLength + 3 + command_buf.byteLength +
                    alg_buf.byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf.byteLength +
                    signDataBuf.byteLength);
                var pki_payload_length = command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf
                    .byteLength + encryptedPIN_buf.byteLength + signDataBuf.byteLength;
                pki_buffer.set(new Uint8Array(gtheaderbuffer), 0);
                pki_header[0] = 0xE5;
                pki_header[1] = pki_payload_length >> 8
                pki_header[2] = pki_payload_length;
                pki_buffer.set(new Uint8Array(pki_header), gtheaderbuffer.byteLength);
                pki_buffer.set(new Uint8Array(command_buf), gtheaderbuffer.byteLength + 3);
                pki_buffer.set(new Uint8Array(alg_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength);
                pki_buffer.set(new Uint8Array(ecpubkey_buf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength);
                pki_buffer.set(new Uint8Array(encryptedPIN_buf), gtheaderbuffer.byteLength + 3 +
                    command_buf.byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength);
                pki_buffer.set(new Uint8Array(signDataBuf), gtheaderbuffer.byteLength + 3 + command_buf
                    .byteLength + alg_buf.byteLength + ecpubkey_buf.byteLength + encryptedPIN_buf
                    .byteLength);

                console.log("sign-ckalabel-safari: " + bufToHex(pki_buffer));

                var getAssertionChallenge = {
                    'challenge': challenge,
                    "userVerification": "discouraged"
                }
                var idList = [{
                    id: pki_buffer,
                    transports: ["usb", "nfc"],
                    type: "public-key"
                }];

                getAssertionChallenge.allowCredentials = idList;
                console.log('List getAssertionChallenge', getAssertionChallenge)

                navigator.credentials.get({
                        'publicKey': getAssertionChallenge
                    })
                    .then((newCredentialInfo) => {

                        alert('Sign finished');
                        console.log('SUCCESS', newCredentialInfo)
                        console.log("Sign", newCredentialInfo.response.signature)
                        const sign = newCredentialInfo.response.signature;
                        var str = String.fromCharCode.apply(null, new Uint8Array(sign));

                        document.getElementById('show-sign').value = "Data:" + "\n" + signData +
                            "\n" +
                            "sign:" + "\n" + btoa(str);

                    })
                    .catch((error) => {
                        alert(error)
                        console.log('FAIL', error)
                    })

            });
        })


        function base64EncodeURL(byteArray) {
            return btoa(Array.from(new Uint8Array(byteArray)).map(val => {
                return String.fromCharCode(val);
            }).join('')).replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
        };

        function toUTF8Array(str) {

            var utf8 = [];
            for (var i = 0; i < str.length; i++) {
                var charcode = str.charCodeAt(i);
                if (charcode < 0x80) utf8.push(charcode);
                else if (charcode < 0x800) {
                    utf8.push(0xc0 | (charcode >> 6),
                        0x80 | (charcode & 0x3f));
                } else if (charcode < 0xd800 || charcode >= 0xe000) {
                    utf8.push(0xe0 | (charcode >> 12),
                        0x80 | ((charcode >> 6) & 0x3f),
                        0x80 | (charcode & 0x3f));
                }
                // surrogate pair
                else {
                    i++;
                    // UTF-16 encodes 0x10000-0x10FFFF by
                    // subtracting 0x10000 and splitting the
                    // 20 bits of 0x0-0xFFFFF into two halves
                    charcode = 0x10000 + (((charcode & 0x3ff) << 10) |
                        (str.charCodeAt(i) & 0x3ff));
                    utf8.push(0xf0 | (charcode >> 18),
                        0x80 | ((charcode >> 12) & 0x3f),
                        0x80 | ((charcode >> 6) & 0x3f),
                        0x80 | (charcode & 0x3f));
                }
            }
            return utf8;
        }
    </script>



</body>

</html>